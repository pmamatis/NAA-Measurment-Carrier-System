.TH "Config/lwipopts.h" 3 "Wed Apr 3 2024" "NAA-Measurement-Carrier-System" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Config/lwipopts.h
.SH SYNOPSIS
.br
.PP
\fC#include 'lwip/arch\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBNO_SYS\fP   0"
.br
.ti -1c
.RI "#define \fBLWIP_NETIF_API\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_NETCONN\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_SOCKET\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_SO_RCVTIMEO\fP   1"
.br
.ti -1c
.RI "#define \fBSYS_LIGHTWEIGHT_PROT\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_DNS\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_TCPIP_CORE_LOCKING\fP   1"
.br
.ti -1c
.RI "#define \fBLOCK_TCPIP_CORE\fP()   \fBsys_lock_tcpip_core\fP()"
.br
.ti -1c
.RI "#define \fBUNLOCK_TCPIP_CORE\fP()   \fBsys_unlock_tcpip_core\fP()"
.br
.ti -1c
.RI "#define \fBLWIP_MARK_TCPIP_THREAD\fP()   \fBsys_mark_tcpip_thread\fP()"
.br
.ti -1c
.RI "#define \fBLWIP_ASSERT_CORE_LOCKED\fP()   \fBsys_check_core_locking\fP()"
.br
.ti -1c
.RI "#define \fBMEM_ALIGNMENT\fP   4"
.br
.ti -1c
.RI "#define \fBMEM_SIZE\fP   (22 * 1024)"
.br
.ti -1c
.RI "#define \fBMEMP_NUM_PBUF\fP   15"
.br
.ti -1c
.RI "#define \fBMEMP_NUM_UDP_PCB\fP   6"
.br
.ti -1c
.RI "#define \fBMEMP_NUM_TCP_PCB\fP   10"
.br
.ti -1c
.RI "#define \fBMEMP_NUM_TCP_PCB_LISTEN\fP   6"
.br
.ti -1c
.RI "#define \fBMEMP_NUM_TCP_SEG\fP   22"
.br
.ti -1c
.RI "#define \fBMEMP_NUM_SYS_TIMEOUT\fP   10"
.br
.ti -1c
.RI "#define \fBPBUF_POOL_SIZE\fP   5"
.br
.ti -1c
.RI "#define \fBLWIP_SINGLE_NETIF\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_IPV4\fP   1"
.br
.ti -1c
.RI "#define \fBIP_FORWARD\fP   0"
.br
.ti -1c
.RI "#define \fBIP_REASSEMBLY\fP   1"
.br
.ti -1c
.RI "#define \fBIP_FRAG\fP   1"
.br
.ti -1c
.RI "#define \fBIP_DEFAULT_TTL\fP   255"
.br
.ti -1c
.RI "#define \fBLWIP_ARP\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_TCP\fP   1"
.br
.ti -1c
.RI "#define \fBTCP_TTL\fP   \fBIP_DEFAULT_TTL\fP"
.br
.ti -1c
.RI "#define \fBTCP_QUEUE_OOSEQ\fP   0"
.br
.ti -1c
.RI "#define \fBTCP_MSS\fP   (1500 \- 40) /* TCP_MSS = (Ethernet MTU \- IP header size \- TCP header size) */"
.br
.ti -1c
.RI "#define \fBTCP_SND_BUF\fP   (6 * \fBTCP_MSS\fP)"
.br
.ti -1c
.RI "#define \fBTCP_SND_QUEUELEN\fP   (3 * \fBTCP_SND_BUF\fP) / \fBTCP_MSS\fP"
.br
.ti -1c
.RI "#define \fBTCP_WND\fP   (2 * \fBTCP_MSS\fP)"
.br
.ti -1c
.RI "#define \fBTCP_LISTEN_BACKLOG\fP   1"
.br
.ti -1c
.RI "#define \fBTCP_DEFAULT_LISTEN_BACKLOG\fP   0xFF"
.br
.ti -1c
.RI "#define \fBLWIP_ICMP\fP   1"
.br
.ti -1c
.RI "#define \fBICMP_TTL\fP   \fBIP_DEFAULT_TTL\fP"
.br
.ti -1c
.RI "#define \fBLWIP_IGMP\fP   0"
.br
.ti -1c
.RI "#define \fBLWIP_RAW\fP   0"
.br
.ti -1c
.RI "#define \fBRAW_TTL\fP   \fBIP_DEFAULT_TTL\fP"
.br
.ti -1c
.RI "#define \fBLWIP_BROADCAST_PING\fP   0"
.br
.ti -1c
.RI "#define \fBLWIP_MULTICAST_PING\fP   0"
.br
.ti -1c
.RI "#define \fBLWIP_DHCP\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_DHCP_DOES_ACD_CHECK\fP   1"
.br
.ti -1c
.RI "#define \fBLWIP_UDP\fP   1"
.br
.ti -1c
.RI "#define \fBUDP_TTL\fP   \fBIP_DEFAULT_TTL\fP"
.br
.ti -1c
.RI "#define \fBLWIP_STATS\fP   0"
.br
.ti -1c
.RI "#define \fBLWIP_PROVIDE_ERRNO\fP"
.br
.ti -1c
.RI "#define \fBCHECKSUM_GEN_IP\fP   1"
.br
.ti -1c
.RI "#define \fBCHECKSUM_GEN_UDP\fP   1"
.br
.ti -1c
.RI "#define \fBCHECKSUM_GEN_TCP\fP   1"
.br
.ti -1c
.RI "#define \fBCHECKSUM_CHECK_IP\fP   1"
.br
.ti -1c
.RI "#define \fBCHECKSUM_CHECK_UDP\fP   1"
.br
.ti -1c
.RI "#define \fBCHECKSUM_CHECK_TCP\fP   1"
.br
.ti -1c
.RI "#define \fBDEFAULT_THREAD_STACKSIZE\fP   3000"
.br
.ti -1c
.RI "#define \fBDEFAULT_THREAD_PRIO\fP   3"
.br
.ti -1c
.RI "#define \fBLWIP_IPV6\fP   0"
.br
.ti -1c
.RI "#define \fBLWIP_IPV6_NUM_ADDRESSES\fP   3"
.br
.ti -1c
.RI "#define \fBLWIP_IPV6_AUTOCONFIG\fP   0"
.br
.ti -1c
.RI "#define \fBLWIP_IPV6_DHCP6\fP   0"
.br
.ti -1c
.RI "#define \fBLWIP_IPV6_DHCP6_STATELESS\fP   \fBLWIP_IPV6_DHCP6\fP"
.br
.ti -1c
.RI "#define \fBLWIP_DEBUG\fP   1"
.br
.ti -1c
.RI "#define \fBU8_F\fP   'c'"
.br
.ti -1c
.RI "#define \fBS8_F\fP   'c'"
.br
.ti -1c
.RI "#define \fBX8_F\fP   '02x'"
.br
.ti -1c
.RI "#define \fBU16_F\fP   'u'"
.br
.ti -1c
.RI "#define \fBS16_F\fP   'd'"
.br
.ti -1c
.RI "#define \fBX16_F\fP   'x'"
.br
.ti -1c
.RI "#define \fBU32_F\fP   'u'"
.br
.ti -1c
.RI "#define \fBS32_F\fP   'd'"
.br
.ti -1c
.RI "#define \fBX32_F\fP   'x'"
.br
.ti -1c
.RI "#define \fBSZT_F\fP   'u'"
.br
.ti -1c
.RI "#define \fBTCPIP_MBOX_SIZE\fP   32"
.br
.ti -1c
.RI "#define \fBTCPIP_THREAD_STACKSIZE\fP   1024"
.br
.ti -1c
.RI "#define \fBTCPIP_THREAD_PRIO\fP   8"
.br
.ti -1c
.RI "#define \fBDEFAULT_RAW_RECVMBOX_SIZE\fP   12"
.br
.ti -1c
.RI "#define \fBDEFAULT_UDP_RECVMBOX_SIZE\fP   12"
.br
.ti -1c
.RI "#define \fBDEFAULT_TCP_RECVMBOX_SIZE\fP   12"
.br
.ti -1c
.RI "#define \fBDEFAULT_ACCEPTMBOX_SIZE\fP   12"
.br
.ti -1c
.RI "#define \fBLWIP_RAND\fP()   \fBlwip_rand\fP()"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBsys_lock_tcpip_core\fP (void)"
.br
.ti -1c
.RI "void \fBsys_unlock_tcpip_core\fP (void)"
.br
.ti -1c
.RI "void \fBsys_mark_tcpip_thread\fP (void)"
.br
.ti -1c
.RI "void \fBsys_check_core_locking\fP (void)"
.br
.ti -1c
.RI "uint32_t \fBlwip_rand\fP (void)"
.br
.RI "** SNTP Config */ "
.in -1c
.SH "Detailed Description"
.PP 
This file is based on \\src\\include\\lwip\\opt\&.h 
.SH "Macro Definition Documentation"
.PP 
.SS "#define CHECKSUM_CHECK_IP   1"

.SS "#define CHECKSUM_CHECK_TCP   1"

.SS "#define CHECKSUM_CHECK_UDP   1"

.SS "#define CHECKSUM_GEN_IP   1"

.SS "#define CHECKSUM_GEN_TCP   1"

.SS "#define CHECKSUM_GEN_UDP   1"

.SS "#define DEFAULT_ACCEPTMBOX_SIZE   12"
DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections\&. The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when the acceptmbox is created\&. 
.SS "#define DEFAULT_RAW_RECVMBOX_SIZE   12"
DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_RAW\&. The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when the recvmbox is created\&. 
.SS "#define DEFAULT_TCP_RECVMBOX_SIZE   12"
DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_TCP\&. The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when the recvmbox is created\&. 
.SS "#define DEFAULT_THREAD_PRIO   3"
DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread\&. The priority value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created\&. 
.SS "#define DEFAULT_THREAD_STACKSIZE   3000"
DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread\&. The stack size value itself is platform-dependent, but is passed to sys_thread_new() when the thread is created\&. 
.SS "#define DEFAULT_UDP_RECVMBOX_SIZE   12"
DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a NETCONN_UDP\&. The queue size value itself is platform-dependent, but is passed to sys_mbox_new() when the recvmbox is created\&. 
.SS "#define ICMP_TTL   \fBIP_DEFAULT_TTL\fP"

.SS "#define IP_DEFAULT_TTL   255"
IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers\&. 
.SS "#define IP_FORWARD   0"
IP_FORWARD==1: Enables the ability to forward IP packets across network interfaces\&. If you are going to run lwIP on a device with only one network interface, define this to 0\&. 
.SS "#define IP_FRAG   1"
IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU\&. Note that this option does not affect incoming packet sizes, which can be controlled via IP_REASSEMBLY\&. 
.SS "#define IP_REASSEMBLY   1"
IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets\&. Note that this option does not affect outgoing packet sizes, which can be controlled via IP_FRAG\&. 
.SS "#define LOCK_TCPIP_CORE()   \fBsys_lock_tcpip_core\fP()"

.SS "#define LWIP_ARP   1"
LWIP_ARP==1: Enable ARP functionality\&. 
.SS "#define LWIP_ASSERT_CORE_LOCKED()   \fBsys_check_core_locking\fP()"

.SS "#define LWIP_BROADCAST_PING   0"
LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only) 
.SS "#define LWIP_DEBUG   1"

.SS "#define LWIP_DHCP   1"

.SS "#define LWIP_DHCP_DOES_ACD_CHECK   1"
LWIP_DHCP_DOES_ACD_CHECK==1: Perform address conflict detection on the dhcp address\&. 
.SS "#define LWIP_DNS   1"
LWIP_DNS==1: Turn on DNS module\&. UDP must be available for DNS transport\&. 
.SS "#define LWIP_ICMP   1"

.SS "#define LWIP_IGMP   0"

.SS "#define LWIP_IPV4   1"
LWIP_IPV4==1: Enable IPv4 
.SS "#define LWIP_IPV6   0"
LWIP_IPV6==1: Enable IPv6 
.SS "#define LWIP_IPV6_AUTOCONFIG   0"
LWIP_IPV6_AUTOCONFIG==1: Enable stateless address autoconfiguration as per RFC 4862\&. 
.SS "#define LWIP_IPV6_DHCP6   0"
LWIP_IPV6_DHCP6==1: enable DHCPv6 stateful/stateless address autoconfiguration\&. 
.SS "#define LWIP_IPV6_DHCP6_STATELESS   \fBLWIP_IPV6_DHCP6\fP"
LWIP_IPV6_DHCP6_STATELESS==1: enable DHCPv6 stateless address autoconfiguration\&. 
.SS "#define LWIP_IPV6_NUM_ADDRESSES   3"
LWIP_IPV6_NUM_ADDRESSES: Number of IPv6 addresses per netif\&. 
.SS "#define LWIP_MARK_TCPIP_THREAD()   \fBsys_mark_tcpip_thread\fP()"

.SS "#define LWIP_MULTICAST_PING   0"
LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only) 
.SS "#define LWIP_NETCONN   1"
LWIP_NETCONN==1: Enable Netconn API (require to use api_lib\&.c) 
.SS "#define LWIP_NETIF_API   1"
LWIP_NETIF_API==1: Support netif api (in netifapi\&.c) 
.SS "#define LWIP_PROVIDE_ERRNO"
LWIP_PROVIDE_ERRNO==1: Let lwIP provide ERRNO values and the \\'errno\\' variable\&. If this is disabled, cc\&.h must either define \\'errno\\', include <errno\&.h>, define LWIP_ERRNO_STDINCLUDE to get <errno\&.h> included or define LWIP_ERRNO_INCLUDE to <errno\&.h> or equivalent\&. 
.SS "#define LWIP_RAND()   \fBlwip_rand\fP()"

.SS "#define LWIP_RAW   0"
LWIP_RAW==1: Enable application layer to hook into the IP layer itself\&. 
.SS "#define LWIP_SINGLE_NETIF   1"

.SS "#define LWIP_SO_RCVTIMEO   1"
LWIP_SO_RCVTIMEO==1: Enable receive timeout for sockets/netconns and SO_RCVTIMEO processing\&. 
.SS "#define LWIP_SOCKET   1"
LWIP_SOCKET==1: Enable Socket API (require to use sockets\&.c) 
.SS "#define LWIP_STATS   0"

.SS "#define LWIP_TCP   1"

.SS "#define LWIP_TCPIP_CORE_LOCKING   1"

.SS "#define LWIP_UDP   1"

.SS "#define MEM_ALIGNMENT   4"
MEM_ALIGNMENT: should be set to the alignment of the CPU 
.SS "#define MEM_SIZE   (22 * 1024)"
MEM_SIZE: the size of the heap memory\&. If the application will send a lot of data that needs to be copied, this should be set high\&. 
.SS "#define MEMP_NUM_PBUF   15"

.SS "#define MEMP_NUM_SYS_TIMEOUT   10"

.SS "#define MEMP_NUM_TCP_PCB   10"

.SS "#define MEMP_NUM_TCP_PCB_LISTEN   6"

.SS "#define MEMP_NUM_TCP_SEG   22"

.SS "#define MEMP_NUM_UDP_PCB   6"

.SS "#define NO_SYS   0"
NO_SYS 0: Use RTOS; 1: Bare metal lwIP 
.SS "#define PBUF_POOL_SIZE   5"

.SS "#define RAW_TTL   \fBIP_DEFAULT_TTL\fP"

.SS "#define S16_F   'd'"

.SS "#define S32_F   'd'"

.SS "#define S8_F   'c'"

.SS "#define SYS_LIGHTWEIGHT_PROT   1"
SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain critical regions during buffer allocation, deallocation and memory allocation and deallocation\&. 
.SS "#define SZT_F   'u'"

.SS "#define TCP_DEFAULT_LISTEN_BACKLOG   0xFF"

.SS "#define TCP_LISTEN_BACKLOG   1"

.SS "#define TCP_MSS   (1500 \- 40) /* TCP_MSS = (Ethernet MTU \- IP header size \- TCP header size) */"

.SS "#define TCP_QUEUE_OOSEQ   0"

.SS "#define TCP_SND_BUF   (6 * \fBTCP_MSS\fP)"

.SS "#define TCP_SND_QUEUELEN   (3 * \fBTCP_SND_BUF\fP) / \fBTCP_MSS\fP"

.SS "#define TCP_TTL   \fBIP_DEFAULT_TTL\fP"

.SS "#define TCP_WND   (2 * \fBTCP_MSS\fP)"

.SS "#define TCPIP_MBOX_SIZE   32"

.SS "#define TCPIP_THREAD_PRIO   8"

.SS "#define TCPIP_THREAD_STACKSIZE   1024"

.SS "#define U16_F   'u'"

.SS "#define U32_F   'u'"

.SS "#define U8_F   'c'"

.SS "#define UDP_TTL   \fBIP_DEFAULT_TTL\fP"

.SS "#define UNLOCK_TCPIP_CORE()   \fBsys_unlock_tcpip_core\fP()"

.SS "#define X16_F   'x'"

.SS "#define X32_F   'x'"

.SS "#define X8_F   '02x'"

.SH "Function Documentation"
.PP 
.SS "uint32_t lwip_rand (void)"

.PP
** SNTP Config */ 
.IP "\(bu" 2
This is the macro that will be used by the SNTP app to set the time every time it contacts the server */ 
.PP

.SS "void sys_check_core_locking (void)"

.SS "void sys_lock_tcpip_core (void)"

.SS "void sys_mark_tcpip_thread (void)"

.SS "void sys_unlock_tcpip_core (void)"

.SH "Author"
.PP 
Generated automatically by Doxygen for NAA-Measurement-Carrier-System from the source code\&.
